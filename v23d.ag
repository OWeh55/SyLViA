#include <string>
#include <vector>
#include <limits>
#include <iostream>
#include <fstream>

#include <image.h>

#include "v23d.h"

/*AppGen:Global*/

using namespace std;

/*AppGen
  prog: analyse video from coded light
  para: filename, optional, string, fnb, Video filename, ""

  opt: F, first, int, first, First frame to use, 0
  opt: L, last, int, last, Last frame to use, -1
  opt2: last = -1 for all frames

  opt: c, cyclelength, int, cycleLength, Approximate cycle length (skip coarse detection), -1
  opt: s, cyclestart, int, cycleStart, First frame of cycle (skip coarse detection), -1

  opt: t, threshold, Double, threshold, Threshold for detection, 2

  opt: S, sequence, String, sequenceDescription, Description of sequence, "sc123456789"
  opt2: Meaning of characters
  opt2: s - sinus function
  opt2: c - sinus function
  opt2: 1,2,...,9 - gray code bit
  opt2: all pattern are projected as positive and negative
  opt2: Sequence is expected to start with black to white change
  opt: x, xmin, int, Xmin, Window x minimum, 0
  opt: X, xmax, int, Xmax, Window x maximum, -1
  opt: y, ymin, int, Ymin, Window y minimum, 0
  opt: Y, ymax, int, Ymax, Window y maximum, -1
  opt: D, debug, Int, debug, Debug flags (bitwise or), 0
  opt2:  1 - write gnuplot files in cycle detection
  opt2:  2 - debug boundary detection
  opt2:  4 - debug pattern extraction
  opt2:  8 - debug phase detection
  opt2: 16 - debug read video
  opt: v, verbose, Void, verbose, Be verbose, false
  opt: h, help, usage, , Hilfe
AppGen*/

// sequence of pattern
int sequenceLength;

/*AppGen:Main*/
int main(int argc, char** argv)
{
  /*AppGen:MainEnd*/
  try
    {

      int nFrames;
      int xSize;
      int ySize;

      if (debug != 0)
        verbose = true;

      // prepare window:
      // set to inf if not given by user
      if (Xmax <= 0)
        Xmax = numeric_limits<int>::max();
      if (Ymax <= 0)
        Ymax = numeric_limits<int>::max();
      Window readWindow(Xmin, Ymin, Xmax, Ymax);

      // prepare globals for sequence
      sequenceLength = sequenceDescription.length() * 2 + 2;
      if (verbose)
        cout << "sequence: " << sequenceDescription
             << "   (" << sequenceLength << " pattern) " << endl;

      vector<double> gsum;
      vector<double> dgsum;

      int fps = 0;
      scanVideo(fnb,
                gsum, dgsum,
                fps,
                first, last, 'g', readWindow);

      nFrames = gsum.size();
      if (nFrames == 0)
        throw IceException("readImages", "No frames read");

      if (verbose)
        cout << "read " << nFrames << " images" << endl;

      //  cout << gsum.size() << " " << dgsum.size() << endl;
      vector<double> sequenceBoundaries;
      analysis(gsum, dgsum,
               fps,
               sequenceBoundaries,
               cycleLength, cycleStart);

      if (verbose)
        {
          cout << "cycle length : " << cycleLength << endl;
          int sequences = sequenceBoundaries.size() - 1;
          cout << "found " << sequences << " sequences" << endl;
          for (int i = 0; i < sequences; i++)
            cout << sequenceBoundaries[i] << " ... "
                 << sequenceBoundaries[i + 1] << endl;
        }

#ifdef IN_MEMORY
      // image vector: all (selected) frames in memory as
      // gray value image
      vector<Image> cv;
      int fps = 0;
      readImages(fnb, cv, fps, first, last, 'g', readWindow);

      nFrames = cv.size();
      if (nFrames == 0)
        throw IceException("readImages", "No frames read");
      if (verbose)
        cout << "read " << nFrames << " images" << endl;
      xSize = cv[0].xsize;
      ySize = cv[0].ysize;

      // prepare globals for sequence
      sequenceLength = sequenceDescription.length() * 2 + 2;
      if (verbose)
        cout << "sequence: " << sequenceDescription
             << "   (" << sequenceLength << " pattern) " << endl;

      // analyse images to find sequences
      vector<double> sequenceBoundaries;
      analysis(cv, fps, sequenceBoundaries, cycleLength, cycleStart);
      if (verbose)
        {
          cout << "cycle length : " << cycleLength << endl;
          int sequences = sequenceBoundaries.size() - 1;
          cout << "found " << sequences << " sequences" << endl;
          for (int i = 0; i < sequences; i++)
            cout << sequenceBoundaries[i] << " ... "
                 << sequenceBoundaries[i + 1] << endl;
        }

      // extract sequences: one image for every pattern
      vector<vector<ImageD>> extractedPattern;
      extractPattern(cv, sequenceBoundaries, extractedPattern);

      // calculate per sequence: phase and mask
      vector<ImageD> phaseImages;
      vector<Image> maskImages;
      calcPhases(extractedPattern, phaseImages, maskImages, threshold);
#endif

    }
  catch (IceException& ex)
    {
      cerr << "exception (ICE): " << ex.what() << endl;
    }
  catch (const char* msg)
    {
      cerr << "exception (char*): " << msg << endl;
    }
  return 0;
}
