#include <string>
#include <vector>
#include <limits>
#include <iostream>
#include <fstream>

#include <image.h>
#include "FileName.h"

#include "v23d.h"
#include "v2file.h"

/*AppGen:Global*/

using namespace std;

/*AppGen
  prog: analyse video from coded light
  para: filename, optional, string, fn, Video filename, ""

  opt: F, first, int, first, First frame to use, 0
  opt: L, last, int, last, Last frame to use, -1
  opt2: last = -1 for all frames

  opt: x, xmin, int, Xmin, Window x minimum, 0
  opt: X, xmax, int, Xmax, Window x maximum, -1
  opt: y, ymin, int, Ymin, Window y minimum, 0
  opt: Y, ymax, int, Ymax, Window y maximum, -1

  opt: n, nframes, int, framesToAverage, frames to average per pattern, 1

  opt: o, output, String, outFile, Name of output files, "v23d"
  opt2:  use -o- for no output
  opt: i, interactive, void, interactive, Decide interactively about writing result, false
  opt: p, phaseresolution, int, phaseResolution, Subdivision of phase, 32

  opt: c, cyclelength, int, cycleLength, Approximate cycle length (skip coarse detection), -1
  opt: s, cyclestart, int, cycleStart, First frame of cycle (skip coarse detection), -1

  opt: T, threshold, Double, thresholdg, Threshold for graycode detection, 5
  opt: t, threshold, Double, thresholdp, Threshold for phase detection, 1

  opt: S, sequence, String, sequenceDescription, Description of sequence, "sc123456789"
  opt2: Meaning of characters
  opt2: s - sinus function
  opt2: c - cosinus function
  opt2: 1,2,...,9 - gray code bit
  opt2: all pattern are projected as positive and negative
  opt2: sequence is expected to start with black to white change

  opt: D, debug, Int, debug, Debug flags (bitwise or), 0
  opt2:  1 - write gnuplot files in cycle detection
  opt2:  2 - debug boundary detection
  opt2:  4 - debug pattern extraction / write pattern files
  opt2:  8 - debug phase detection
  opt2: 16 - debug read video

  opt: v, verbose, Void, verbose, Be verbose, false
  opt: h, help, usage, , Hilfe
AppGen*/

// sequence of pattern
int sequenceLength;

/*AppGen:Main*/
int main(int argc, char** argv)
{
  /*AppGen:MainEnd*/
  try
    {
      if (framesToAverage % 2 != 1)
        throw IceException("command line parameters", "frames to average must be odd");

      if (debug != 0)
        verbose = true;

      // prepare window:
      // set to \inf if not given by user
      if (Xmax <= 0)
        Xmax = numeric_limits<int>::max();
      if (Ymax <= 0)
        Ymax = numeric_limits<int>::max();
      Window readWindow(Xmin, Ymin, Xmax, Ymax);

      // prepare globals for sequence
      sequenceLength = sequenceDescription.length() * 2 + 2;
      if (verbose)
        cout << "sequence: " << sequenceDescription
             << "   (" << sequenceLength << " pattern) " << endl;

      FileName filename(fn);

      bool shallWriteResult = false;
      if (!outFile.empty())
        {
          if (outFile == "-") // explicitely no output wished -> debug or interactive mode
            {
              if (debug == 0)
                interactive = true;
            }
          else
            {
              FileName of(outFile); // remove all but filename
              outFile = of.getName();
              shallWriteResult = true;
            }
        }

      if (debug == 0 && outFile.empty())
        throw IceException("v23d", "no result and no debug");

      vector<double> gsum;
      vector<double> dgsum;
      int nFrames;

      int fps = 0;
      scanVideo(filename,
                gsum, dgsum,
                fps,
                first, last, 'g', readWindow);

      nFrames = gsum.size();
      if (nFrames == 0)
        throw IceException("scanVideo", "No frames read");

      if (verbose)
        cout << "found " << nFrames << " images" << endl;

      vector<double> sequenceBoundaries;
      analysis(gsum, dgsum,
               fps,
               sequenceBoundaries,
               cycleLength, cycleStart);

      int nSequences = sequenceBoundaries.size() - 1;
      if (verbose)
        {
          cout << "cycle length : " << cycleLength << endl;

          cout << "found " << nSequences << " sequences" << endl;
	  /*
          for (int i = 0; i < nSequences; i++)
            cout << sequenceBoundaries[i] << " ... "
                 << sequenceBoundaries[i + 1] << endl;
	  */
        }

      if (nSequences == 0)
        throw IceException("analysis", "No sequences found");

      FileName resDir(filename);
      resDir.setExtension("");

      if (shallWriteResult)
        {
          system(("mkdir -p " + resDir.getFullName()).c_str());
        }

      // extract all sequences
      VideoFile v(filename.getFullName());

      bool abort = false;
      for (int i = 0; i < sequenceBoundaries.size() - 1 && !abort; i++)
        {
          if (verbose)
            cout << "extracting sequence " <<  sequenceBoundaries[i] << " ... " << sequenceBoundaries[i + 1] << endl;

          string iString(to_string(i));
          while (iString.size() < 3)
            iString = "0" + iString;

          ColorImage cImg;
          ColorImage deviation;
          vector<ImageD> seq;

          readSequence(v,
                       sequenceBoundaries[i], sequenceBoundaries[i + 1],
                       sequenceLength,
                       'g',  // color mode
                       readWindow,
                       framesToAverage,
                       seq, cImg, deviation);

          if (debug & 4)
            {
              for (int i = 0; i < seq.size(); i++)
                {
                  FileName pOut;
                  pOut.setPath(resDir.getFullName());
                  pOut.setName(outFile + "_" +
                               iString + "_pattern+" +
                               sequenceDescription[i]);
                  pOut.setExtension("pgm");
                  Image pattern;
                  pattern.create(seq[i].xsize, seq[i].ysize, 255);
                  WindowWalker w(pattern);
                  for (w.init(); !w.ready(); w.next())
                    {
                      pattern.setPixelLimited(w, 128 + seq[i].getPixel(w));
                    }
                  pattern.write(pOut);
                  cout << "debug: wrote " << pOut.getFullName() << endl;
                }
            }

          ImageD phase;
          Image mask;
          calcPhases(seq, phase, mask, thresholdg, thresholdp);

          bool reallyWrite = shallWriteResult;

          if (interactive)
            {
              Show(ON, cImg, "texture");
              Show(ON, deviation, "deviation");
              Show(GRAY, phase);
              Show(OVERLAY, mask);
              if (shallWriteResult)
                {
                  if (!Ask("Store this Image"))
                    reallyWrite = false;
                }
              else
                {
                  if (!Ask("continue"))
                    abort = true;
                }

              Show(OFF, phase);
            }

          if (reallyWrite)
            {

              FileName texture;
              texture.setPath(resDir.getFullName());
              texture.setName(outFile + "_" + iString + "_texture");
              texture.setExtension("pnm");
              cImg.write(texture.getFullName());
              if (verbose)
                cout << "wrote " << texture.getFullName() << endl;

              FileName phaseN;
              phaseN.setPath(resDir.getFullName());
              phaseN.setName(outFile + "_" + iString + "_phase");
              phaseN.setExtension("pgm");
              Image iPhase;
              iPhase.create(phase.xsize, phase.ysize, 0xffff);
              WindowWalker w(phase);
              phase.adaptLimits();
              for (w.init(); !w.ready(); w.next())
                {
                  // we expect phase values > 0
                  // or roundInt(phase * phaseResolution) >= 1
                  int intPhase = RoundInt(phase.getPixel(w) * phaseResolution);
                  if (mask.getPixel(w) == 0) // phase valid
                    {
                      if (intPhase > 0xffff)
                        throw IceException("phase", "value exceeds word (reduce phaseResolution)");
                      if (intPhase < 1)
                        throw IceException("phase", "unexpected value < 1 : " + to_string(intPhase));
                      iPhase.setPixel(w, intPhase);
                    }
                  else
                    iPhase.setPixel(w, 0);
                }

              iPhase.write(phaseN.getFullName());
              if (verbose)
                cout << "wrote " << phaseN.getFullName() << endl;
            }
        }
    }
  catch (IceException& ex)
    {
      cerr << "exception: " << ex.what() << endl;
    }
  catch (const char* msg)
    {
      cerr << "exception (char*): " << msg << endl;
    }
  return 0;
}
