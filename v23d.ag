#include <string>
#include <vector>
#include <limits>
#include <iostream>
#include <fstream>

#include <image.h>

#include "v23d.h"

/*AppGen:Global*/

using namespace std;

/*AppGen
  prog: analyse video from coded light
  para: filename, optional, string, fnb, Video filename, ""

  opt: F, first, int, first, First frame to use, 0
  opt: L, last, int, last, Last frame to use, -1
  opt2: last = -1 for all frames

  opt: c, cyclelength, int, cycleLength, Approximate cycle length (skip coarse detection), -1
  opt: s, cyclestart, int, cycleStart, First frame of cycle (skip coarse detection), -1

  opt: T, threshold, Double, thresholdg, Threshold for graycode detection, 5
  opt: t, threshold, Double, thresholdp, Threshold for phase detection, 1

  opt: S, sequence, String, sequenceDescription, Description of sequence, "sc123456789"
  opt2: Meaning of characters
  opt2: s - sinus function
  opt2: c - sinus function
  opt2: 1,2,...,9 - gray code bit
  opt2: all pattern are projected as positive and negative
  opt2: Sequence is expected to start with black to white change
  opt: x, xmin, int, Xmin, Window x minimum, 0
  opt: X, xmax, int, Xmax, Window x maximum, -1
  opt: y, ymin, int, Ymin, Window y minimum, 0
  opt: Y, ymax, int, Ymax, Window y maximum, -1
  opt: D, debug, Int, debug, Debug flags (bitwise or), 0
  opt2:  1 - write gnuplot files in cycle detection
  opt2:  2 - debug boundary detection
  opt2:  4 - debug pattern extraction
  opt2:  8 - debug phase detection
  opt2: 16 - debug read video
  opt: v, verbose, Void, verbose, Be verbose, false
  opt: h, help, usage, , Hilfe
AppGen*/

// sequence of pattern
int sequenceLength;

/*AppGen:Main*/
int main(int argc, char** argv)
{
  /*AppGen:MainEnd*/
  try
    {

      int nFrames;

      if (debug != 0)
        verbose = true;

      // prepare window:
      // set to inf if not given by user
      if (Xmax <= 0)
        Xmax = numeric_limits<int>::max();
      if (Ymax <= 0)
        Ymax = numeric_limits<int>::max();
      Window readWindow(Xmin, Ymin, Xmax, Ymax);

      // prepare globals for sequence
      sequenceLength = sequenceDescription.length() * 2 + 2;
      if (verbose)
        cout << "sequence: " << sequenceDescription
             << "   (" << sequenceLength << " pattern) " << endl;

      vector<double> gsum;
      vector<double> dgsum;

      int fps = 0;
      scanVideo(fnb,
                gsum, dgsum,
                fps,
                first, last, 'g', readWindow);

      nFrames = gsum.size();
      if (nFrames == 0)
        throw IceException("readImages", "No frames read");

      if (verbose)
        cout << "read " << nFrames << " images" << endl;

      //  cout << gsum.size() << " " << dgsum.size() << endl;
      vector<double> sequenceBoundaries;
      analysis(gsum, dgsum,
               fps,
               sequenceBoundaries,
               cycleLength, cycleStart);

      int nSequences = sequenceBoundaries.size() - 1;
      if (verbose)
        {
          cout << "cycle length : " << cycleLength << endl;

          cout << "found " << nSequences << " sequences" << endl;
          for (int i = 0; i < nSequences; i++)
            cout << sequenceBoundaries[i] << " ... "
                 << sequenceBoundaries[i + 1] << endl;
        }

      if (nSequences == 0)
        throw IceException("analysis", "No sequences found");

      // extract all sequences
      VideoFile v(fnb);
      for (int i = 0; i < sequenceBoundaries.size() - 1; i++)
        {
          if (verbose)
            cout << "extracting sequence " <<  sequenceBoundaries[i] << " ... " << sequenceBoundaries[i + 1] << endl;
          vector<ImageD> seq;
          ColorImage cImg;
          readSequence(v,
                       sequenceBoundaries[i], sequenceBoundaries[i + 1],
                       'g',  // color mode
                       seq, cImg);
          /*
                Show(ON, cImg);
                GetChar();
          */
          ImageD phase;
          Image mask;
          calcPhases(seq, phase, mask, thresholdg, thresholdp);
          /*
          Show(GRAY,phase);
          Show(OVERLAY,mask);
          GetChar();
          */
        }
    }
  catch (IceException& ex)
    {
      cerr << "exception (ICE): " << ex.what() << endl;
    }
  catch (const char* msg)
    {
      cerr << "exception (char*): " << msg << endl;
    }
  return 0;
}
