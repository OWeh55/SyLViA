#include <fstream>
#include <iostream>
#include <string>
#include "image.h"
#include "FileName.h"

#include "v2trafo.h"
#include "v2file.h"

/*AppGen:Global*/

using namespace std;

/*AppGen
  prog: Extract 3d data for triangle viewer
  para: filename, required, string, baseFileName, Filename of phase or texture image, ""
  opt: c, calibfile, string, calibFilename, Name of calibration file,""
  opt: p, phaseresolution, double, phaseResolution, Resolution of phase image, 32.0
  opt: x, xmin, double, xMin, minimum x, -10000
  opt: X, xmax, double, xMax, maximum x, 10000
  opt: y, ymin, double, yMin, minimum y, -10000
  opt: Y, ymax, double, yMax, maximum y, 10000
  opt: z, zmin, double, zMin, minimum z, -10000
  opt: Z, zmax, double, zMax, maximum z, 10000
  opt: l, maxlength, double, maxLength, maximum length of triangle edges, 1000

  opt: n, nocolor, void, noColor, Ignore texture, false

  opt: d, display, void, display, display images, false
  opt: D, debug, Void, debug, print debug information, false
  opt: v, verbose, Void, verbose, be verbose, false
AppGen*/

class sBox
{
public:
  sBox(double xMin, double xMax,
       double yMin, double yMax,
       double zMin, double zMax):
    xMin(xMin), xMax(xMax),
    yMin(yMin), yMax(yMax),
    zMin(zMin), zMax(zMax)
  {
  };
  bool inRange(const Vector3d& xyz)
  {
    return  xyz.x >= xMin && xyz.x <= xMax &&
            xyz.y >= yMin && xyz.y <= yMax &&
            xyz.z >= zMin && xyz.z <= zMax;
  }
private:
  double xMin;
  double xMax;
  double yMin;
  double yMax;
  double zMin;
  double zMax;
};

void writeTriangle(ostream& os,
                   IPoint p1, IPoint p2, IPoint p3,
                   const matrix<int>& numbers,
                   const ColorImage& textureImage,
                   const matrix<Vector3d>& xyzs,
                   const ColorValue& maxVal,
                   double maxLength,
                   bool ignoreColor)
{
  if (textureImage.inside(p1) &&
      textureImage.inside(p2) &&
      textureImage.inside(p3))
    {
      int n1 = numbers[p1.x][p1.y] - 1;
      int n2 = numbers[p2.x][p2.y] - 1;
      int n3 =  numbers[p3.x][p3.y] - 1;
      if (n1 >= 0 && n2 >= 0 && n3 >= 0)
        {
          // second selection criteria: max edge length
          Vector3d xyz1 = xyzs[p1.x][p1.y];
          Vector3d xyz2 = xyzs[p2.x][p2.y];
          Vector3d xyz3 = xyzs[p3.x][p3.y];
          if (
            (xyz1 - xyz2).length() < maxLength &&
            (xyz2 - xyz3).length() < maxLength &&
            (xyz3 - xyz1).length() < maxLength
          )
            {
              if (!ignoreColor)
                {
                  ColorValue c1 = textureImage.getPixel(p1);
                  ColorValue c2 = textureImage.getPixel(p2);
                  ColorValue c3 = textureImage.getPixel(p3);
                  ColorValue cc = (c1 + c2 + c3) * 0.3333;
                  os << "C " << (double)cc.red / maxVal.red;
                  os << " " << (double)cc.green / maxVal.green;
                  os << " " << (double)cc.blue / maxVal.blue << endl;
                }
              os << "T " << n1 << " " << n2 << " " << n3 << endl;
            }
        }
    }
}

void maxColorValue(ColorValue& maxVal, const ColorValue& c)
{
  if (c.red > maxVal.red)
    maxVal.red = c.red;
  if (c.green > maxVal.green)
    maxVal.green = c.green;
  if (c.blue > maxVal.blue)
    maxVal.blue = c.blue;
}

/*AppGen:Main*/
int main(int argc, char** argv)
{
  /*AppGen:MainEnd*/
  try
    {
      sBox selectBox(xMin, xMax, yMin, yMax, zMin, zMax);
      string textureFN;
      string phaseFN;
      string calibFN;
      fileNames(baseFileName, textureFN, phaseFN, calibFN);
      ColorImage textureImage;
      textureImage.read(textureFN);
      Image phaseImage;
      phaseImage.read(phaseFN);
      int xSize = textureImage.xsize;
      int ySize = textureImage.ysize;
      if (phaseImage.xsize != xSize || phaseImage.ysize != ySize)
        throw IceException("read files", "image sizes differ");
      if (display)
        {
          Show(ON, textureImage);
          Show(GRAY, phaseImage);
        }

      vector<double> para;

      if (calibFilename.empty())
        {
          FileName fn(calibFN);
          if (!readCalib(calibFN, para))
            {
              vector<string> calFiles;
              Directory(calFiles, fn.getPath() + "/*cal", DIR_FILE);
              if (calFiles.empty())
                throw IceException("Load calib", "No file found");
              calibFN = fn.getPath() + "/" + calFiles[0];
              readCalib(calibFN, para);
            }
        }
      else
        {
          calibFN = calibFilename;
          readCalib(calibFN, para);
        }
      if (verbose)
        {
          cout << "using parameter from " << calibFN << endl;
          printPara(para);
        }

      // file for triangle viewer
      ofstream os("xyz.tv");

      ImageD depth;
      depth.create(xSize, ySize, -400, 400);
      depth.set(400.0);

      if (display)
        {
          Show(GRAY, depth, "depth");
        }

      Image mark;
      mark.create(xSize, ySize, 16);
      mark.set(0);
      if (display)
        {
          Show(OVERLAY, mark, "selected");
        }

      ColorValue maxVal(0);

      WindowWalker w(phaseImage);
      // we collect all valid points (with phase) and number
      // them. No more than xSize*ySize points + reserve
      matrix<int> numbers(xSize, ySize);
      numbers.set(0.0);
      matrix<Vector3d> xyzs(xSize, ySize);
      xyzs.set(Vector3d(0, 0, 0));
      int pNumber = 0;
      for (w.init(); !w.ready(); w.next())
        {
          int hPhase = phaseImage.getPixel(w);
          if (hPhase != 0)
            {
              Point uv(w);
              double u2 = hPhase / phaseResolution;
              Vector3d xyz;
              reconstruct(para, uv, u2, xyz);
              xyzs[w.x][w.y] = xyz;
              depth.setPixel(w, xyz.z);
              if (selectBox.inRange(xyz))
                {
                  numbers[w.x][w.y] = pNumber + 1;
                  pNumber++;
                  // determine max colorvalue of selected pixels
                  ColorValue c = textureImage.getPixel(w);
                  maxColorValue(maxVal, c);
                  // we invert y to get a right handed system
                  os << "P " << xyz.x << " " << -xyz.y << " " << xyz.z << endl;
                }
              else
                mark.setPixel(w, 2);
            }
          else
            mark.setPixel(w, 1);
        }

      IPoint dx(1, 0);
      IPoint dy(0, 1);

      for (w.init(); !w.ready(); w.next())
        {
          writeTriangle(os,
                        w, w + dx, w + dy,
                        numbers, textureImage, xyzs,
                        maxVal,
                        maxLength,
                        noColor);
          writeTriangle(os,
                        w + dy, w + dx, w + dx + dy,
                        numbers, textureImage, xyzs,
                        maxVal,
                        maxLength,
                        noColor);
        }
      os.close();

      if (display)
        {
          GetChar();
          Show(OFF, depth);
        }
    }
  catch (const IceException& ex)
    {
      cerr << "Exception: " << ex.what() << endl;
    }
  return OK;
}
