#include <string>
#include <vector>
#include <iostream>

#include <image.h>

/*AppGen:Global*/

using namespace std;

/*AppGen
  prog: Create image sequence
  para: filename, optional, string, fnb, Filename for images/video, ""

  opt: H, horizontal, void, horizontal, Horizontal pattern, false

  opt: s, sequence, string, sequence, Pattern description, "sc123456789"
  opt2:  b - black
  opt2:  w - white
  opt2:  c - cosinus
  opt2:  s - sinus
  opt2:  0..9,A..F - gray code bit 0 .. 15 (upper case letters!)
  opt2:  after each pattern the inverse pattern is added.
  opt2:  Use -i to switch off this.
  opt: i, noinverse, void, noInverse, Do not add inverse pattern, false
  opt: r, repeat, int, repeat, Repetitions of each pattern, 3
  opt: R, srepeat, int, srepeat, Repetitions of sequence, 1

  opt: D, debugimage, void, singleImage, Create single image with patterns (for debug), false

  opt: f, framespersecond, int, fps, Frames per second, 30
  opt: X, xsize, int, sizeX, Image size X, 848
  opt: Y, ysize, int, sizeY, Image size Y, 480

  opt: d, display, void, display, Show images, false
  opt2:  includes wait = true
  opt: w, wait, Void, wait, Wait after each pattern, false
  opt: v, verbose, Void, verbose, Be verbose, false
  opt: h, help, usage, , This help
AppGen*/

void writeImage(const Image& img, int repeat, VideoFile& vf)
{
  if (vf.isOpen())
    {
      for (int i = 0; i < repeat; i++)
        vf.write(img);
    }

  if (wait)
    GetChar();
}

void makeImage(const vector<bool>& pattern, const Image& img, bool horizontal)
{
  if (horizontal)
    {
      for (int y = 0; y < img.ysize; y++)
        {
          int v = pattern[y] ? 255 : 0;
          for (int x = 0; x < img.xsize; x++)
            img.setPixel(x, y, v);
        }
    }
  else
    {
      for (int y = 0; y < img.ysize; y++)
        for (int x = 0; x < img.xsize; x++)
          {
            int v = pattern[x] ? 255 : 0;
            img.setPixel(x, y, v);
          }
    }
}

vector<bool> makePhaseShift(int nCols, int phase, int nStripes)
{
  if (nCols < 4)
    throw "phase shift must have cycle length >= 3";
  vector<bool> result;
  for (int i = 0; i < nStripes; i++)
    {
      int k = Mod(i - phase, nCols);
      result.push_back(k < nCols / 2);
    }
  return result;
}

vector<bool> makeGrayCode(int bit, int nStripes)
{
  vector<bool> result;
  int mask = 1 << bit;
  for (int i = 0; i < nStripes; ++i)
    {
      int graycode = i ^ (i >> 1);
      result.push_back((graycode & mask) != 0);
    }
  return result;
}

vector<bool> inverse(const vector<bool>& v)
{
  vector<bool> result(v.size());
  for (int i = 0; i < v.size(); i++)
    result[i] = !v[i];
  return result;
}

int getP(const string& sequence, int& i)
{
  int result;
  if (i >= sequence.size())
    throw "Parameter missing";
  char c = toupper(sequence[i]);
  i++;
  if (c >= '0' && c <= '9')
    {
      result = c - '0';
    }
  else if (c >= 'A' && c <= 'Z')
    result = c - 'A' + 10;
  else
    throw "wrong Parameter";
  return result;
}

void getRange(const string& sequence, int& i, int& first, int& last)
{
  first = getP(sequence, i);
  last = first;
  if (sequence[i] == '-')
    {
      i++;
      last = getP(sequence, i);
    }
}
/*AppGen:Main*/
int main(int argc, char** argv)
{
  /*AppGen:MainEnd*/
  try
    {
      if (fnb.empty() || wait)
        display = true;

      if (display)
        wait = true;

      Image img;
      img.create(sizeX, sizeY, 255);
      if (display)
        Show(ON, img);

      int nStripes = horizontal ? sizeY : sizeX;
      vector<vector<bool> > patterns;

      if (verbose)
        {
          cout << "Generating patterns " << sequence;
          if (noInverse)
            cout << " w/o inverse pattern";
          else
            cout << " with inverse pattern";
          cout << endl;
        }

      // create extended sequence description from basic description
      string xSequence;
      // for compatibility we add a black to white transition if not yet contained
      bool hasBlack = false;
      bool hasWhite = false;
      for (int i = 0; i < sequence.size(); i++)
        {
          char c = sequence[i];
          switch (c)
            {
            case 's':
              xSequence += "s4";
              if (!noInverse)
                xSequence += "S4";
              break;
            case 'c':
              xSequence += "c4";
              if (!noInverse)
                xSequence += "C4";
              break;
            case 'b':
              xSequence += "b0"; // number is dummy here
              hasBlack = true;
              if (!noInverse)
                {
                  xSequence += "B0";
                  hasWhite = true;
                }
              break;
            case 'w':
              xSequence += "B0"; // number is dummy here
              hasWhite = true;
              if (!noInverse)
                {
                  xSequence += "b0";
                  hasBlack = true;
                }
              break;
            default:
              if ((c >= '0' && c <= '9') || (c >= 'A' && c <= 'F'))
                {
                  xSequence += "g";
                  xSequence += c;
                  if (!noInverse)
                    {
                      xSequence += "G";
                      xSequence += c;
                    }
                }
              else
                throw "unknown char in sequence";
            }
        }

      if (! hasBlack || ! hasWhite)
        xSequence += "b0B0";

      cout << sequence << " -> " << xSequence << endl;


      int i = 0;
      while (i < xSequence.size())
        {
          char pc = xSequence[i++];
          int  para = getP(xSequence, i);
          if (verbose)
            {
              cout << i << ": " << pc << para << " ";
              cout.flush();
            }
          switch (pc)
            {
            case 'b':// black
              patterns.push_back(vector<bool>(nStripes, true));
              break;
            case 'B':// inverse black == white
              patterns.push_back(vector<bool>(nStripes, false));
              break;
            case 's':
              patterns.push_back(makePhaseShift(para, 0, nStripes));
              break;
            case 'S':
              patterns.push_back(inverse(makePhaseShift(para, 0, nStripes)));
              break;
            case 'c':
              patterns.push_back(makePhaseShift(para, para / 4, nStripes));
              break;
            case 'C':
              patterns.push_back(inverse(makePhaseShift(para, para / 4, nStripes)));
              break;

            case 'g':
              patterns.push_back(makeGrayCode(para, nStripes));
              break;
            case 'G':
              patterns.push_back(inverse(makeGrayCode(para, nStripes)));
              break;

            default:
              throw "Wrong character in description";
            }
        }
      if (verbose)
        cout << endl;
      int nPatterns = patterns.size();
      if (nPatterns < 1)
        throw "no pattern generated";
      if (singleImage)
        {
          if (horizontal)
            {
              for (int y = 0; y < sizeY; y++)
                for (int x = 0; x < sizeX; x++)
                  {
                    int p = x * nPatterns / sizeX;
                    img.setPixel(x, y, patterns[p][y] ? 255 : 0);
                  }
            }
          else
            {
              for (int y = 0; y < sizeY; y++)
                for (int x = 0; x < sizeX; x++)
                  {
                    int p = y * nPatterns / sizeY;
                    img.setPixel(x, y, patterns[p][x] ? 255 : 0);
                  }
            }
          if (!fnb.empty())
            img.write(fnb);
          if (wait)
            GetChar();
        }
      else
        {
          VideoFile vf;
          if (!fnb.empty())
            {
              vf.open(fnb, ios_base::out);
              vf.setPara(sizeX, sizeY, 255, fps);
            }

          for (int r = 0; r < srepeat; r++)
            {
              if (verbose)
                cout << "Sequence " << (r + 1) << " of " << srepeat << endl;
              for (int k = 0; k < patterns.size(); k++)
                {
                  makeImage(patterns[k], img, horizontal);
                  writeImage(img, repeat, vf);
                }
            }
        }
    }
  catch (const char* msg)
    {
      cerr << endl << "Exception: " << msg << endl;
    }
  return OK;
}
